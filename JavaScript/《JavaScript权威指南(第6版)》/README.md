
# 这里是这本书的读书笔记。 #

## 第5章，语句 ##
1.var声明的变量是无法用delete删除的

2.如果var语句中变量没有指定初始化表达式，那么这个变量被初始为undefined

3.变量声明语句会被“提前”至脚本或函数的顶部，但是赋值语句的位置不变

4.使用函数声明语句的话，函数名称和函数体均提前

5.和var语句一样，函数声明语句创建的变量也是无法删除的

6.for/in循环并不会遍历对象的所有属性，只有“可枚举”的属性才会遍历到

7.for/in循环是按照属性定义的先后顺序来枚举简单对象的属性，先定义的属性先枚举

8.break和continue是JavaScript中唯一可以使用语句标签的语句

9.with,debugger,use strict

10.严格模式和非严格模式下的区别


## 第6章，对象        ##   
1.原型式继承-->原形链

2.对象属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性

3.属性特性：可写、可枚举、可配置

4.对象特性：①对象的原型指向另外一个对象，本对象的属性继承自它的原型对象

           ②对象的类是一个标识对象类型的字符串

           ③对象的扩展标记指明了是否可以向该对象添加新的属性

5.①内置对象是由ECMAScript规范定义的对象或类

  ②宿主对象是由JavaScript解析器所嵌入的宿主环境（比如浏览器）定义的

  ③自定义对象是由运行中的JavaScript代码创建的对象

  ④自有属性是直接在对象中定义的属性

  ⑤继承属性是在对象的原型对象中定义的属性

6.创建对象：可以通过对象直接量、关键字new和Object.create()函数来创建对象

7.通过点(.)或方括号([])运算符来获取属性的值

8.在JavaScript中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关

9.避免对象/对象属性不存在而报错的写法

		var len =  book && book.subtitle && book.subtitle.length;

10.delete运算符可以删除对象的属性。需要注意的是，delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性

11.in,hasOwnPreperty()和propertyIsEnumerable()

12.get和set：存取器属性定义时，没有使用function关键字，而是使用get和set。注意，这里没有使用冒号将属性名和函数体分隔开，但是函数体的结束和下一个方法或数据属性之间有逗号分隔

13.数据属性的四个特性分别是他的值、可写性、可枚举性和可配置性

14.存取器属性的4个特性是读取、可写、可枚举性和可配置性

15.在ECMAScript5中，将对象作为参数传入Object.getPrototypeOf()可以查询它的原型。在ECMAScript3中，经常使用表达式o.constructor.prototype来检测一个对象的原型。

16.要想检测一个对象是否是另一个对象的原型，请使用isPrototypeOf()方法

17.通过将对象传入Object.esExtensible(),来判断该对象是否是可扩转的。如果想将对象转换为不可扩展的，需要调用Object.preventExtensions(),将带转换的对象作为参数传进去。注意，一旦将对象转换为不可扩展的，就无法再将其转换回可扩展的了

18.Object.seal()除了能够将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置。可以使用Object.isSealed()来检测对象是否封闭

19.Objcect.freeze()将更严格的锁定对象--"冻结",除了将对象设置为不可扩展的和将属性设置为不可配置的之外，还可以将它自由的所有数据属性设置为只读。使用Object.isFrozen()来检测对象是否冻结

20.对象序列化（serialization）是指将对象的状态转换为字符串，也可以将字符串还原为对象，ECMAScript5提供了内置的函数JSON.stringify()和JSON.parse()用来序列化和还原JavaScript对象

21.toString(),toLocaleString(),toJSON(),valueOf()

## 第7章，数组 ##
1.JavaScript的数组是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可以有不同的类型

2.JavaScript数组可能是稀疏的：数组元素的索引不一定要连续的，他们之间可以有空缺

3.数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个

4.如果为一个数组元素赋值，他的索引i大于或等于现有数组的长度时，length属性的值将设置为i+1

5.当设置length属性为一个小于当前长度的非负整数n时，当前鼠族中那些索引值大于或等于n的元素将从中删除

6.push(),unshift(),delete,pop(),shift(),splice()

7.对一个数组元素使用delete不会修改数组的length属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，他就变成稀疏数组

8.forEach()

9.Array.join(),String.split();Array.reverse(),Array.sort();Array.concat(),Array.slice(),Array.splice();push(),pop();unshift(),shift();toString(),toLocaleString();map(),filter(),every(),some();reduce(),reduceRight();indexOf(),lastIndexOf();Array.isArray();

## 第8章，函数 ##
1.区分实参和形参

2.如果构造函数没有形参，JavaScript构造函数调用的语法是允许省略实参列表和圆括号的

3.当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值

4.当调用函数的时候传入的实参个数超过函数定义时的形参个数时，没有办法直接获得未命名值的引用

5.在函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象，通过数字下标就能访问传入函数的实参值

6.在ECMAScript 5严格模式中，对callee和caller这两个属性的读写操作都会产生一个类型错误。而在非严格模式下，ECMAScript表中规范规定callee属性指代当前正在执行的函数。caller是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数

7.定义函数的时候，传入的实参都写入一个单独的对象中，在调用的时候传入一个对象，对象中的名/值对是真正需要的实参数据

8.在函数中声明的变量在整个函数体内都是可见的，在函数的外部是不可见的。不在任何函数内声明的变量是全局变量，在整个JavaScript程序中都是可见的

9.命名空间技术：

				(function(){

						//模块代码

				}());

10.JavaScript函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的

11.函数的length属性是只读属性，它代表函数形参的数量，也就是在函数定义时给出的实参个数，通常也是在函数调用时期望传入函数的实参个数

12.每一个函数都包含一个prototype属性，这个属性是指向一个对象的引用，这个对象称作“原型对象”。每一个函数都包含不同的原型对象。当函数用做构造函数的时候，新创建的对象会从原型对象上集成属性

13.caller()和apply()的第一个实参是要调用函数的母对象，他是调用上下文，在函数体内通过this来获得对他的引用。在ECMAScript 5的严格模式中，call()和apply()的第一个实参都会变成this的值，哪怕传入的实参是原始值甚至是null或undefined。在ECMASCript 3和非严格模式中，传入的null和undefined都会被全局对象代替，而其他原始值则会被相应的包装对象所替代

14.区别f.call(o,1,2)和f.apply(o,[1,2])

15.bind()方法主要作用就是将函数绑定至某个对象。当在函数f()上调用bind()方法并传入一个对象o作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数f()当作o的方法来调用

16.如果bind()返回的函数用做构造函数，将忽略传入bind()的this，原始函数就会以构造函数的形式调用，其实参也已经绑定。由bind()方法所返回的函数并不包含prototype属性

17.大多数（非全部）函数的toString方法的实现都返回函数的完整源码，内置函数往往返回一个类似"[native code]"的字符串作为函数体

18.Function()构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串

19.关于Function()构造函数有几点需要注意

   ①Function()构造函数允许JavaScript在运行时动态地创建并编译函数

   ②每次调用Function()构造函数都会解析函数体，并创建新的函数对象

   ③Function()构造函数所创建的函数并不是使用此法作用域，而是会在顶层函数执行

20.所谓高阶函数就是操作函数的函数，它接受一个或多个函数作为参数，并返回一个新的函数

21.可以将上次的结算结果缓存起来。在函数式编程当中，这种缓存技巧叫做“记忆”

## 第9章，块和模块 ##

1.在JavaScript中，类的所有实例对象都从一个原型对象上继承属性

2.从某种意义上讲，定义构造函数既是定义类，并且类名首字母要大写，而普通的函数和方法都是首字母小写

3.原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，他们才是属于同一个类的的实例

4.当使用instanceof运算符来检测对象是否属于某个类时会用到构造函数

5.每个JavaScript函数（ECMAScript 5中的Function.bind()方法返回的函数除外）都自动拥有一个prototype属性。这个属性值是一个对象，这个对象包含唯一一个不可枚举属性constructor

6.在JavaScript中定义类的步骤可以缩减为一个分三步的算法：第一步，先定义一个构造函数，并设置初始化新对象的实例属性；第二部，给构造函数的prototype对象定义实例的方法；第三步，给构造函数定义类字段和类属性

7.对象从其原型继承属性，如果创建对象之后原型的属性发生变化，也会影响到继承这个原型的所有实例对象

8.instanceof运算符，左操作数是待检测其类的对象，右操作数是定义类的构造函数。尽管右操作数是构造函数，但计算过程中实际上是检测了对象的继承关系，而不是检测创建对象的构造函数

9.如果你想检测对象的原形链上是否存在某个特定的原型对象，可以使用isPrototypeOf()方法，这样就可以不实用构造函数作为中介

10.instanceof运算符和isPrototypeOf()方法的缺点是，我们无法通过对象来获得类名，只能检测对象是否属于指定的类名。在客户端JavaScript中还有一个比较严重的不足，就是在多窗口和多框架子页面的web应用中兼容性不佳。每个窗口和框架子页面都具有独立的执行上下文，每个上下文都包含独有的全局变量和一组构造函数

11.constructor属性可以识别对象是否属于某个类。不足之处和instanceof一样，在多个执行上下文的场景中他是无法正常工作。同样，在JavaScript中也并非所有的对象都包含constructor属性。

12.JavaScript的相等运算符比较对象时，比较的是引用而不是值。也就是说，给定两个对象引用，如果要看他们是否指向同一个对象，不是检查这两个对象是否具有相同的属性名和属性值，而是直接比较这两个独立的对象是否相等，或者比较他们的顺序

13.ECMAScript 5给属性特性增加了方法支持（getter、setter、可枚举性、可写性和可配置性），而且增加了对象可扩展性的限制

14.Object.defineProperty(),Object.defineProperties(),Object.preventExtensions(),Object.seal(),Object.freeze(),Object.create()

## 第10章，正则表达式的模式匹配 ##

1.正则表达式是一个描述字符模式的对象，JavaScript的RegExp类表示正则表达式。JavaScript的正则表达式语法是Prel5的正则表达式语法的大型子集

2.ECMAScript 3规范规定，一个正则表达式直接量会在执行到它时转换为一个RegExp对象，同一段代码表示正则表达式直接量的每次运算都返回同一个对象。ECMAScript 5规范则做了相反的规定，同一段代码所表示的正则表达式直接量的每次运算都返回新对象

3.正则表达式中所有字母和数字都是按照字面含义进行匹配的

4.\o  NUL字符(\u0000) ;   \t  制表符(\u0009) ;   \n  换行符(\u00A)  ;
  \v  垂直制表符(\u000B) ;   \f  换页符(\u000C) ;   \r  回车符(\u000D)  ; \xnn  由十六制数nn指定的拉丁字符 ;  \uxxxx 由十六制数xxxx指定的Unicode字符  ;  \cX  控制字符^X

## 第11章，JavaScript的子集和扩展 ##

1.Crockford提炼出的子集部分不包含with和continue语句以及eval()函数。他提倡使用函数定义表达式而不是函数定义语句来定义函数。该子集要求：循环体和条件分支都使用花括号括起来，它不允许在循环体和条件分支中只包括一条语句时省略花括号，任何语句只要不是以花括号结束都应该是用分号做结尾

2.eval()和Function()构造函数在任何安全子集里都是禁止使用的，因为他们可以执行任意代码，而且JavaScript无法对这些代码做静态分析

3.禁止使用this关键字，因为函数（在非严格模式中）可以通过this访问全局对象。而沙箱系统的一个重要目的就是阻止全局对象的访问

4.禁止使用with语句，因为with语句增加了静态代码检查的难度

5.禁止使用某些全局变量。

6.禁止使用某些属性和方法，以免在沙箱中的代码拥有过多的权限。

7.静态分析可以有效的防止带有点(.)运算符的属性存取表达式去读写特殊属性。

## 第12章，服务器端JavaScript ##
