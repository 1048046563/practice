
# 这里是这本书的读书笔记。 #

## 第5章，语句 ##
1.var声明的变量是无法用delete删除的</br>
2.如果var语句中变量没有指定初始化表达式，那么这个变量被初始为undefined</br>
3.变量声明语句会被“提前”至脚本或函数的顶部，但是赋值语句的位置不变</br>
4.使用函数声明语句的话，函数名称和函数体均提前</br>
5.和var语句一样，函数声明语句创建的变量也是无法删除的</br>
6.for/in循环并不会遍历对象的所有属性，只有“可枚举”的属性才会遍历到</br>
7.for/in循环是按照属性定义的先后顺序来枚举简单对象的属性，先定义的属性先枚举</br>
8.break和continue是JavaScript中唯一可以使用语句标签的语句</br>
9.with,debugger,use strict</br>
10.严格模式和非严格模式下的区别</br>

## 第6章，对象        ##   
1.原型式继承-->原形链</br>
2.对象属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性</br>
3.属性特性：可写、可枚举、可配置</br>
4.对象特性：①对象的原型指向另外一个对象，本对象的属性继承自它的原型对象</br>
           ②对象的类是一个标识对象类型的字符串</br>
           ③对象的扩展标记指明了是否可以向该对象添加新的属性</br>
5.①内置对象是由ECMAScript规范定义的对象或类</br>
  ②宿主对象是由JavaScript解析器所嵌入的宿主环境（比如浏览器）定义的</br>
  ③自定义对象是由运行中的JavaScript代码创建的对象</br>
  ④自有属性是直接在对象中定义的属性</br>
  ⑤继承属性是在对象的原型对象中定义的属性</br>
6.创建对象：可以通过对象直接量、关键字new和Object.create()函数来创建对象</br>
7.通过点(.)或方括号([])运算符来获取属性的值</br>
8.在JavaScript中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关</br>
9.避免对象/对象属性不存在而报错的写法</br>
		var len =  book && book.subtitle && book.subtitle.length;
10.delete运算符可以删除对象的属性。需要注意的是，delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性</br>
11.in,hasOwnPreperty()和propertyIsEnumerable()</br>
12.get和set：存取器属性定义时，没有使用function关键字，而是使用get和set。注意，这里没有使用冒号将属性名和函数体分隔开，但是函数体的结束和下一个方法或数据属性之间有逗号分隔。</br>
13.数据属性的四个特性分别是他的值、可写性、可枚举性和可配置性。</br>
14.存取器属性的4个特性是读取、可写、可枚举性和可配置性</br>
15.在ECMAScript5中，将对象作为参数传入Object.getPrototypeOf()可以查询它的原型。在ECMAScript3中，经常使用表达式o.constructor.prototype来检测一个对象的原型。</br>
16.要想检测一个对象是否是另一个对象的原型，请使用isPrototypeOf()方法。</br>
17.通过将对象传入Object.esExtensible(),来判断该对象是否是可扩转的。如果想将对象转换为不可扩展的，需要调用Object.preventExtensions(),将带转换的对象作为参数传进去。注意，一旦将对象转换为不可扩展的，就无法再将其转换回可扩展的了</br>
18.Object.seal()除了能够将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置。可以使用Object.isSealed()来检测对象是否封闭</br>
19.Objcect.freeze()将更严格的锁定对象--"冻结",除了将对象设置为不可扩展的和将属性设置为不可配置的之外，还可以将它自由的所有数据属性设置为只读。使用Object.isFrozen()来检测对象是否冻结</br>
20.对象序列化（serialization）是指将对象的状态转换为字符串，也可以将字符串还原为对象，ECMAScript5提供了内置的函数JSON.stringify()和JSON.parse()用来序列化和还原JavaScript对象</br>
21.toString(),toLocaleString(),toJSON(),valueOf(),</br>

## 第7章，数组 ##
1.JavaScript的数组是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可以有不同的类型</br>
2.JavaScript数组可能是稀疏的：数组元素的索引不一定要连续的，他们之间可以有空缺</br>
3.数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个</br>
4.如果为一个数组元素赋值，他的索引i大于或等于现有数组的长度时，length属性的值将设置为i+1</br>
5.当设置length属性为一个小于当前长度的非负整数n时，当前鼠族中那些索引值大于或等于n的元素将从中删除</br>
6.push(),unshift(),delete,pop(),shift(),splice()</br>
7.对一个数组元素使用delete不会修改数组的length属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，他就变成稀疏数组</br>
8.forEach()</br>
9.Array.join(),String.split();Array.reverse(),Array.sort();Array.concat(),Array.slice(),Array.splice();push(),pop();unshift(),shift();toString(),toLocaleString();map(),filter(),every(),some();reduce(),reduceRight();indexOf(),lastIndexOf();Array.isArray();</br>

## 第8章，函数 ##
1.区分实参和形参</br>
2.如果构造函数没有形参，JavaScript构造函数调用的语法是允许省略实参列表和圆括号的</br>
3.当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值</br>
4.当调用函数的时候传入的实参个数超过函数定义时的形参个数时，没有办法直接获得未命名值的引用</br>
5.在函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象，通过数字下标就能访问传入函数的实参值</br>
6.在ECMAScript 5严格模式中，对callee和caller这两个属性的读写操作都会产生一个类型错误。而在非严格模式下，ECMAScript表中规范规定callee属性指代当前正在执行的函数。caller是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数</br>
7.定义函数的时候，传入的实参都写入一个单独的对象中，在调用的时候传入一个对象，对象中的名/值对是真正需要的实参数据</br>
8.在函数中声明的变量在整个函数体内都是可见的，在函数的外部是不可见的。不在任何函数内声明的变量是全局变量，在整个JavaScript程序中都是可见的</br>
9.命名空间技术：
				(function(){
						//模块代码
				}());</br>
10.JavaScript函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的</br>
11.函数的length属性是只读属性，它代表函数形参的数量，也就是在函数定义时给出的实参个数，通常也是在函数调用时期望传入函数的实参个数</br>
12.每一个函数都包含一个prototype属性，这个属性是指向一个对象的引用，这个对象称作“原型对象”。每一个函数都包含不同的原型对象。当函数用做构造函数的时候，新创建的对象会从原型对象上集成属性</br>
13.caller()和apply()的第一个实参是要调用函数的母对象，他是调用上下文，在函数体内通过this来获得对他的引用。在ECMAScript 5的严格模式中，call()和apply()的第一个实参都会变成this的值，哪怕传入的实参是原始值甚至是null或undefined。在ECMASCript 3和非严格模式中，传入的null和undefined都会被全局对象代替，而其他原始值则会被相应的包装对象所替代</br>
14.区别f.call(o,1,2)和f.apply(o,[1,2])</br>
15.bind()方法主要作用就是将函数绑定至某个对象。当在函数f()上调用bind()方法并传入一个对象o作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数f()当作o的方法来调用</br>
16.如果bind()返回的函数用做构造函数，将忽略传入bind()的this，原始函数就会以构造函数的形式调用，其实参也已经绑定。由bind()方法所返回的函数并不包含prototype属性</br>
17.大多数（非全部）函数的toString方法的实现都返回函数的完整源码，内置函数往往返回一个类似"[native code]"的字符串作为函数体</br>
18.Function()构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串</br>
19.关于Function()构造函数有几点需要注意</br>
   ①Function()构造函数允许JavaScript在运行时动态地创建并编译函数</br>
   ②每次调用Function()构造函数都会解析函数体，并创建新的函数对象</br>
   ③Function()构造函数所创建的函数并不是使用此法作用域，而是会在顶层函数执行</br>
20.