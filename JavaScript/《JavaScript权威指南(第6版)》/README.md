
# 这里是这本书的读书笔记。 #

## 第5章，语句 ##
1.var声明的变量是无法用delete删除的

2.如果var语句中变量没有指定初始化表达式，那么这个变量被初始为undefined

3.变量声明语句会被“提前”至脚本或函数的顶部，但是赋值语句的位置不变

4.使用函数声明语句的话，函数名称和函数体均提前

5.和var语句一样，函数声明语句创建的变量也是无法删除的

6.for/in循环并不会遍历对象的所有属性，只有“可枚举”的属性才会遍历到

7.for/in循环是按照属性定义的先后顺序来枚举简单对象的属性，先定义的属性先枚举

8.break和continue是JavaScript中唯一可以使用语句标签的语句

9.with,debugger,use strict

10.严格模式和非严格模式下的区别


## 第6章，对象        ##   
1.原型式继承-->原形链

2.对象属性名可以是包含空字符串在内的任意字符串，但对象中不能存在两个同名的属性

3.属性特性：可写、可枚举、可配置

4.对象特性：①对象的原型指向另外一个对象，本对象的属性继承自它的原型对象

           ②对象的类是一个标识对象类型的字符串

           ③对象的扩展标记指明了是否可以向该对象添加新的属性

5.①内置对象是由ECMAScript规范定义的对象或类

  ②宿主对象是由JavaScript解析器所嵌入的宿主环境（比如浏览器）定义的

  ③自定义对象是由运行中的JavaScript代码创建的对象

  ④自有属性是直接在对象中定义的属性

  ⑤继承属性是在对象的原型对象中定义的属性

6.创建对象：可以通过对象直接量、关键字new和Object.create()函数来创建对象

7.通过点(.)或方括号([])运算符来获取属性的值

8.在JavaScript中，只有在查询属性时才会体会到继承的存在，而设置属性则和继承无关

9.避免对象/对象属性不存在而报错的写法

		var len =  book && book.subtitle && book.subtitle.length;

10.delete运算符可以删除对象的属性。需要注意的是，delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性

11.in,hasOwnPreperty()和propertyIsEnumerable()

12.get和set：存取器属性定义时，没有使用function关键字，而是使用get和set。注意，这里没有使用冒号将属性名和函数体分隔开，但是函数体的结束和下一个方法或数据属性之间有逗号分隔

13.数据属性的四个特性分别是他的值、可写性、可枚举性和可配置性

14.存取器属性的4个特性是读取、可写、可枚举性和可配置性

15.在ECMAScript5中，将对象作为参数传入Object.getPrototypeOf()可以查询它的原型。在ECMAScript3中，经常使用表达式o.constructor.prototype来检测一个对象的原型。

16.要想检测一个对象是否是另一个对象的原型，请使用isPrototypeOf()方法

17.通过将对象传入Object.esExtensible(),来判断该对象是否是可扩转的。如果想将对象转换为不可扩展的，需要调用Object.preventExtensions(),将带转换的对象作为参数传进去。注意，一旦将对象转换为不可扩展的，就无法再将其转换回可扩展的了

18.Object.seal()除了能够将对象设置为不可扩展的，还可以将对象的所有自有属性都设置为不可配置。可以使用Object.isSealed()来检测对象是否封闭

19.Objcect.freeze()将更严格的锁定对象--"冻结",除了将对象设置为不可扩展的和将属性设置为不可配置的之外，还可以将它自由的所有数据属性设置为只读。使用Object.isFrozen()来检测对象是否冻结

20.对象序列化（serialization）是指将对象的状态转换为字符串，也可以将字符串还原为对象，ECMAScript5提供了内置的函数JSON.stringify()和JSON.parse()用来序列化和还原JavaScript对象

21.toString(),toLocaleString(),toJSON(),valueOf()

## 第7章，数组 ##
1.JavaScript的数组是无类型的：数组元素可以是任意类型，并且同一个数组中的不同元素也可以有不同的类型

2.JavaScript数组可能是稀疏的：数组元素的索引不一定要连续的，他们之间可以有空缺

3.数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个

4.如果为一个数组元素赋值，他的索引i大于或等于现有数组的长度时，length属性的值将设置为i+1

5.当设置length属性为一个小于当前长度的非负整数n时，当前鼠族中那些索引值大于或等于n的元素将从中删除

6.push(),unshift(),delete,pop(),shift(),splice()

7.对一个数组元素使用delete不会修改数组的length属性，也不会将元素从高索引处移下来填充已删除属性留下的空白。如果从数组中删除一个元素，他就变成稀疏数组

8.forEach()

9.Array.join(),String.split();Array.reverse(),Array.sort();Array.concat(),Array.slice(),Array.splice();push(),pop();unshift(),shift();toString(),toLocaleString();map(),filter(),every(),some();reduce(),reduceRight();indexOf(),lastIndexOf();Array.isArray();

## 第8章，函数 ##
1.区分实参和形参

2.如果构造函数没有形参，JavaScript构造函数调用的语法是允许省略实参列表和圆括号的

3.当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值

4.当调用函数的时候传入的实参个数超过函数定义时的形参个数时，没有办法直接获得未命名值的引用

5.在函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象，通过数字下标就能访问传入函数的实参值

6.在ECMAScript 5严格模式中，对callee和caller这两个属性的读写操作都会产生一个类型错误。而在非严格模式下，ECMAScript表中规范规定callee属性指代当前正在执行的函数。caller是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数

7.定义函数的时候，传入的实参都写入一个单独的对象中，在调用的时候传入一个对象，对象中的名/值对是真正需要的实参数据

8.在函数中声明的变量在整个函数体内都是可见的，在函数的外部是不可见的。不在任何函数内声明的变量是全局变量，在整个JavaScript程序中都是可见的

9.命名空间技术：

				(function(){

						//模块代码

				}());

10.JavaScript函数的执行用到了作用域链，这个作用域链是函数定义的时候创建的

11.函数的length属性是只读属性，它代表函数形参的数量，也就是在函数定义时给出的实参个数，通常也是在函数调用时期望传入函数的实参个数

12.每一个函数都包含一个prototype属性，这个属性是指向一个对象的引用，这个对象称作“原型对象”。每一个函数都包含不同的原型对象。当函数用做构造函数的时候，新创建的对象会从原型对象上集成属性

13.caller()和apply()的第一个实参是要调用函数的母对象，他是调用上下文，在函数体内通过this来获得对他的引用。在ECMAScript 5的严格模式中，call()和apply()的第一个实参都会变成this的值，哪怕传入的实参是原始值甚至是null或undefined。在ECMASCript 3和非严格模式中，传入的null和undefined都会被全局对象代替，而其他原始值则会被相应的包装对象所替代

14.区别f.call(o,1,2)和f.apply(o,[1,2])

15.bind()方法主要作用就是将函数绑定至某个对象。当在函数f()上调用bind()方法并传入一个对象o作为参数，这个方法将返回一个新的函数。（以函数调用的方式）调用新的函数将会把原始的函数f()当作o的方法来调用

16.如果bind()返回的函数用做构造函数，将忽略传入bind()的this，原始函数就会以构造函数的形式调用，其实参也已经绑定。由bind()方法所返回的函数并不包含prototype属性

17.大多数（非全部）函数的toString方法的实现都返回函数的完整源码，内置函数往往返回一个类似"[native code]"的字符串作为函数体

18.Function()构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串

19.关于Function()构造函数有几点需要注意

   ①Function()构造函数允许JavaScript在运行时动态地创建并编译函数

   ②每次调用Function()构造函数都会解析函数体，并创建新的函数对象

   ③Function()构造函数所创建的函数并不是使用此法作用域，而是会在顶层函数执行

20.所谓高阶函数就是操作函数的函数，它接受一个或多个函数作为参数，并返回一个新的函数

21.可以将上次的结算结果缓存起来。在函数式编程当中，这种缓存技巧叫做“记忆”

## 第9章，块和模块 ##

1.在JavaScript中，类的所有实例对象都从一个原型对象上继承属性

2.从某种意义上讲，定义构造函数既是定义类，并且类名首字母要大写，而普通的函数和方法都是首字母小写

3.原型对象是类的唯一标识：当且仅当两个对象继承自同一个原型对象时，他们才是属于同一个类的的实例

4.当使用instanceof运算符来检测对象是否属于某个类时会用到构造函数

5.每个JavaScript函数（ECMAScript 5中的Function.bind()方法返回的函数除外）都自动拥有一个prototype属性。这个属性值是一个对象，这个对象包含唯一一个不可枚举属性constructor

6.在JavaScript中定义类的步骤可以缩减为一个分三步的算法：第一步，先定义一个构造函数，并设置初始化新对象的实例属性；第二部，给构造函数的prototype对象定义实例的方法；第三步，给构造函数定义类字段和类属性

7.对象从其原型继承属性，如果创建对象之后原型的属性发生变化，也会影响到继承这个原型的所有实例对象

8.instanceof运算符，左操作数是待检测其类的对象，右操作数是定义类的构造函数。尽管右操作数是构造函数，但计算过程中实际上是检测了对象的继承关系，而不是检测创建对象的构造函数

9.如果你想检测对象的原形链上是否存在某个特定的原型对象，可以使用isPrototypeOf()方法，这样就可以不实用构造函数作为中介

10.instanceof运算符和isPrototypeOf()方法的缺点是，我们无法通过对象来获得类名，只能检测对象是否属于指定的类名。在客户端JavaScript中还有一个比较严重的不足，就是在多窗口和多框架子页面的web应用中兼容性不佳。每个窗口和框架子页面都具有独立的执行上下文，每个上下文都包含独有的全局变量和一组构造函数

11.constructor属性可以识别对象是否属于某个类。不足之处和instanceof一样，在多个执行上下文的场景中他是无法正常工作。同样，在JavaScript中也并非所有的对象都包含constructor属性。

12.JavaScript的相等运算符比较对象时，比较的是引用而不是值。也就是说，给定两个对象引用，如果要看他们是否指向同一个对象，不是检查这两个对象是否具有相同的属性名和属性值，而是直接比较这两个独立的对象是否相等，或者比较他们的顺序

13.ECMAScript 5给属性特性增加了方法支持（getter、setter、可枚举性、可写性和可配置性），而且增加了对象可扩展性的限制

14.Object.defineProperty(),Object.defineProperties(),Object.preventExtensions(),Object.seal(),Object.freeze(),Object.create()

## 第10章，正则表达式的模式匹配 ##

1.正则表达式是一个描述字符模式的对象，JavaScript的RegExp类表示正则表达式。JavaScript的正则表达式语法是Prel5的正则表达式语法的大型子集

2.ECMAScript 3规范规定，一个正则表达式直接量会在执行到它时转换为一个RegExp对象，同一段代码表示正则表达式直接量的每次运算都返回同一个对象。ECMAScript 5规范则做了相反的规定，同一段代码所表示的正则表达式直接量的每次运算都返回新对象

3.正则表达式中所有字母和数字都是按照字面含义进行匹配的

4.\o  NUL字符(\u0000) ;   \t  制表符(\u0009) ;   \n  换行符(\u00A)  ;
  \v  垂直制表符(\u000B) ;   \f  换页符(\u000C) ;   \r  回车符(\u000D)  ; \xnn  由十六制数nn指定的拉丁字符 ;  \uxxxx 由十六制数xxxx指定的Unicode字符  ;  \cX  控制字符^X

## 第11章，JavaScript的子集和扩展 ##

1.Crockford提炼出的子集部分不包含with和continue语句以及eval()函数。他提倡使用函数定义表达式而不是函数定义语句来定义函数。该子集要求：循环体和条件分支都使用花括号括起来，它不允许在循环体和条件分支中只包括一条语句时省略花括号，任何语句只要不是以花括号结束都应该是用分号做结尾

2.eval()和Function()构造函数在任何安全子集里都是禁止使用的，因为他们可以执行任意代码，而且JavaScript无法对这些代码做静态分析

3.禁止使用this关键字，因为函数（在非严格模式中）可以通过this访问全局对象。而沙箱系统的一个重要目的就是阻止全局对象的访问

4.禁止使用with语句，因为with语句增加了静态代码检查的难度

5.禁止使用某些全局变量。

6.禁止使用某些属性和方法，以免在沙箱中的代码拥有过多的权限。

7.静态分析可以有效的防止带有点(.)运算符的属性存取表达式去读写特殊属性。

## 第12章，服务器端JavaScript ##

1.Rhino是基于Java的JavaScript解析器，实现了通过JavaScript程序访问整个Java API

2.Node是Google的V8 JavaScript解析器的一个特别版本，他在底层绑定了POSIX  API，包括文件、进程、流和套接字等，并侧重于异步I/O、网络和HTTP

3.Rhino程序能使用Java的Swing框架创建图形UI,而Node上运行的JavaScript程序可以像shell脚本那样去操作文件

第二部分  客户端JavaScript
------
## 第13章，Web浏览器中的JavaScript ##

1.Window对象是所有客户端JavaScript特性和API的主要接入点。他表示web浏览器的一个窗口或窗体，并且可以用标识符window来引用他。

2.在客户端JavaScript中，window对象也是全局对象。这意味着window对象处于作用域链的顶部，他的属性和方法实际上是全局变量和全局函数。

3.当脚本所在的HTML文件被载入浏览器时，这个脚本里的JavaScript代码只会执行一次

4.在URL后面跟一个javascript：协议限定符，是另一种嵌入JavaScript代码到客户端的方式。

5.脚本的执行在默认情况下都是同步和阻塞。<script/>标签可以有defer和saync属性，这可以改变脚本的执行方式。如果<script/>标签同事有两个属性，同时支持两者的浏览器会遵从async属性并忽略defer属性

6.按照约定，事件处理程序的属性的名字是以“on”开始，后面跟着事件的名字。对于大部分浏览器中的大部分事件来说，会把一个对象传递给事件处理程序作为参数，那个对象的属性提供了事件的详细信息（在Ie里，这些事件信息被存储在全局event对象里，而不是传递给处理程序函数）

7.HTML5定义类一种并发的控制方式，叫做“Web workers”。Web worker是一个用来执行计算密集任务而不冻结用户界面的后台线程。运行在Web worker线程里的代码不能访问文档内容，不能和主线程或其他worker共享状态，只可以和主线程和其他worker通过异步事件进行通信，所以主线程不能检测并发性，并且Web worker不能修改JavaScript程序的基础单线程执行模式

8.客户端JavaScript兼容性和交互性的问题可以归纳为一下三类：演化，未实现，bug

9.要进行渲染模式的特性检测，通常检查document.compatMode属性。如果其值为"CSS1Compat"，则说明浏览器工作在标准模式；如果值为"BackCompat"（或undefined，说明属性根本不存在），则说明浏览器工作在怪异模式

10.<!--[if IE]<script type="text/javascript"></script><![endif]-->

11.JavaScript可访问性的一条重要原则是，设计的代码即使在禁用JavaScript解析器的浏览器中也能正常使用

12.同源策略是对JavaScript代码能够操作哪些web内容的一条完整的安全限制。脚本只能读取搜书文档来源相同的窗口和文档的属性

13.跨文档消息，允许来自一个文档的脚本可以传递文本消息到另一个文档里的脚本，而不管脚本的来源是否不同。调用windows对象上的postMessage()方法，可以一步传递消息事件（可以用onmessage事件处理程序来处理他）到窗口的文档里

14.跨站脚本（xss），是攻击者向目标web站点注入html标签或者脚本

15.防止XSS攻击的方式是，在试用任何不可信的数据来动态的创建文档内容之前，从中移除HTML标签

## 第14章，Window对象 ##

1.setTimeout()和setInterval()可以用来注册在指定的事件之后单次或重复调用的函数

2.window.location === document.location //总是返回true

3.Document对象也有一个URL属性，是文档首次载入后保存该文档的URL的静态字符串

4.Location对象的protocal，host，hostname，port，pathname和search，分别表示URL的各个部分,他们呗称为“RUL分解”属性，同时被Link对象支持

5.Location对象的assign()方法可以使窗口载入并显示你指定的URL中的文档，replace()方法也类似，但他在载入新文档之前会从浏览历史中把当前文档删除。除此之外，Location对象还定义了reloat()方法，可以让浏览器重新载入当前文档

6.History对象是用来把窗口的浏览历史用文档和文档状态列表的形式表示。History对象的back()和forward()方法与浏览器的“后退”和“前进”按钮一样，第三个方法--go()接受一个整数参数，可以在历史列表中先前（正参数）或向后（负参数）跳过任意多个页

7.如果窗口包含多个子窗口（比如iframe元素）,子窗口的浏览历史会按时间顺序穿插在主窗口的历史中，这意味着在主窗口调用history.back()可能会导致其中一个子窗口往回跳转到前一个显示的文档，但主窗口保留当前状态不变

8.Window对象的navigator属性引用的是包含浏览器厂商和版本信息的Navigator对象。它有四个很有用的属性：appName，Web浏览器的全称；appVersion，浏览器厂商和版本信息的详细字符串；userAgent，浏览器在它的USER-AGENT HTTP头部中发送的字符串；paltform，在起上运行浏览器的操作系统的字符串

9.Window对象的screen属性提供了有关窗口显示的大小和可用的颜色数量的信息。属性width和height指定的是以像素为单位的窗口大小。属性availWith和availHeight指定的是实际可用的显示大小。属性colorDepth指定的是显示的BPP值

10.Window对象提供了三个方法来向用户显示简单的对话框。alert()向用户显示一条消息并等待用户关闭对话框。confirm()也显示一条信息，要求用户单击“确定”或“取消”按钮，并返回一个布尔值。promptly()同样也显示一条信息，等待用户输入字符串，并返回那个字符串

11.如果文档包含一个<button id="okay"/>元素，可以通过全局变量okay来引用此元素

12。一个Web浏览器窗口可能在桌面上包含多个标签页，每个标签页都是独立的“浏览上下文”，每一个上下文都有独立的Window对象，而且互相之间互不干扰。

13.Window.open()载入指定的URL到新的或已存在的窗口中，并返回那个窗口的Window对象

## 第15章，脚本化文档 ##

1.文档对象模型（DOM）是表示和操作HTML和XML文档内容的基础API。首先，应该理解HTML或XML文档的嵌套元素在DOM树对象中的表示。

2.Node定义了一下重要属性：parentNode:该节点的父节点；childNodes:该节点的子节点的实时表示；firstChild、lastChild:该节点的子节点中的第一个和最后一个；nextSibling、previoursSibling:该节点的兄弟节点中的前一个和下一个；nodeType:该节点的类型；nodeValue:Text节点或Comment节点的文本内容；nodeName:元素的标签名，以大写形式表示

3.HTML5还在Element对象上定义了dataset属性。该属性指代一个对象，他的各个属性对应于去掉前缀的data-属性。因此dataset.x应该保存data-x属性的值。带连字符的属性对应于驼峰命名属性名

## 第16章，脚本化CSS ##

1.层叠样式表（css）是一种指定HTML文档视觉表现的标准。它允许设计师准确的指定文档元素的字体、颜色、外边距、缩进、边框，甚至是定位

2.利用css的@font-face规则可以下载并使用自定义字体

